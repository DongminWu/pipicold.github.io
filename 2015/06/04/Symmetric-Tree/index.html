<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="description" content="The blog of myself"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/atom.xml" title="PIPICOLD" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>leetcode, 判断对称二叉树 - PIPICOLD</title><link rel="stylesheet" href="/css/main.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--></head><body><header class="head"><h1 class="head-title u-fl"><a href="/">PIPICOLD</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/" class="head-nav__link">Home</a></li><li class="head-nav__item"><a href="/archives" class="head-nav__link">Archives</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2015-06-03T22:00:00.000Z" class="post__time">June 4, 2015</time><h1 class="post__title"><a href="/2015/06/04/Symmetric-Tree/">leetcode, 判断对称二叉树</a></h1></header><div class="post__main echo"><p> 题目:</p>
<blockquote>
<p><strong>Symmetric Tree</strong></p>
<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree is symmetric:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    1</div><div class="line">   / \</div><div class="line">  2   2</div><div class="line">/ \ / \</div><div class="line">3  4 4  3</div></pre></td></tr></table></figure>
<p>But the following is not:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">    1</div><div class="line">   / \</div><div class="line">  2   2</div><div class="line">   \   \</div><div class="line">   3    3</div><div class="line">``` </div><div class="line"></div><div class="line">&gt;Note:</div><div class="line">&gt;Bonus points if you could solve it both recursively and iteratively.</div><div class="line"> </div><div class="line">&gt;confused what &quot;&#123;1,#,2,3&#125;&quot; means? &gt; read more on how binary tree is serialized on OJ.</div><div class="line"> </div><div class="line">&gt;OJ&apos;s Binary Tree Serialization:</div><div class="line"> </div><div class="line">&gt;The serialization of a binary tree follows a level order traversal, where &apos;#&apos; signifies a path terminator where no node exists below.</div><div class="line"> </div><div class="line">&gt;Here&apos;s an example:</div><div class="line"> &gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>   1<br>  / \<br> 2   3<br>    /<br>   4<br>    \<br>     5<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;The above binary tree is serialized as `&#123;1,2,3,#,#,4,#,#,5&#125;`. </div><div class="line"></div><div class="line">刚刚看的时候觉得挺难得, 应该, 因为你看对称啊什么的很难解决,</div><div class="line"></div><div class="line">后来看到这个OJ的二叉树表示法的提示之后就想诶能不能通过吧二叉树转化为列表然后比较列表是否对称就行了啊</div><div class="line"></div><div class="line">说起二叉树转化成列表就又想到了**前序, 中序, 后序**遍历</div><div class="line"></div><div class="line">比如前序遍历, 它的遍历方法是`根-&gt;左-&gt;右`</div><div class="line"></div><div class="line">所以如果是镜像二叉树的话, 前序遍历的结果应该是相当于原始二叉树的`根-&gt;右-&gt;左`</div><div class="line"></div><div class="line">所以如果</div><div class="line"></div><div class="line">原始二叉树: `根-&gt;左-&gt;右`遍历</div><div class="line">镜像二叉树: `根-&gt;右-&gt;左`遍历</div><div class="line"></div><div class="line">他们分别得到的列表应该是相同的. </div><div class="line">就用这个来判断</div><div class="line"></div><div class="line">提交的时候发现不能完全用教科书上的遍历方法</div><div class="line"></div><div class="line">因为有这个case:</div><div class="line"></div><div class="line">`[1,2,2,null,3,null,3]`</div><div class="line"></div><div class="line">就是这样的树</div></pre></td></tr></table></figure></p>
<pre><code>1
</code></pre><p>   /   \<br>  2    2<br> /  \ /  \</p>
<h1 id="3-3"><a href="#3-3" class="headerlink" title="3 #   3"></a>3 #   3</h1><p>(# == null)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">所以也要把空的子节点记录下来</div><div class="line"></div><div class="line"></div><div class="line">最后A过的python代码如下</div><div class="line"></div><div class="line">```python</div><div class="line"># Definition for a binary tree node.</div><div class="line"># class TreeNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.left = None</div><div class="line">#         self.right = None</div><div class="line">class Solution:</div><div class="line">    # @param &#123;TreeNode&#125; root</div><div class="line">    # @return &#123;boolean&#125;</div><div class="line">    def isSymmetric(self, root):</div><div class="line">        def preorder_left_first(node):</div><div class="line">            ret=[];</div><div class="line">            if node == None:</div><div class="line">                return [None]</div><div class="line">            ret.append(node.val)</div><div class="line">            ret = ret + preorder_left_first(node.left)</div><div class="line">            ret = ret + preorder_left_first(node.right)</div><div class="line">            return ret</div><div class="line">        def preorder_right_first(node):</div><div class="line">            ret=[];</div><div class="line">            if node == None:</div><div class="line">                return [None]</div><div class="line">            ret.append(node.val)</div><div class="line">            ret = ret + preorder_right_first(node.right)</div><div class="line">            ret = ret + preorder_right_first(node.left)</div><div class="line">            return ret</div><div class="line">        # logic start here</div><div class="line">        if root in [None,[],&#123;&#125;]:</div><div class="line">            return True</div><div class="line">        if (root.left == None and root.right == None):</div><div class="line">            return True</div><div class="line">        if root.left == None or root.right == None:</div><div class="line">            return False</div><div class="line">        left_root = root.left</div><div class="line">        right_root = root.right</div><div class="line">        if left_root.val != right_root.val:</div><div class="line">            return False</div><div class="line">        else:</div><div class="line">            right_ret= preorder_right_first(right_root)</div><div class="line">            left_ret = preorder_left_first(left_root)</div><div class="line">            if right_ret == left_ret:</div><div class="line">                return True</div><div class="line">            else:</div><div class="line">                return False</div></pre></td></tr></table></figure></p>
</div><footer class="post__foot u-cf"><a href="/2015/06/04/Symmetric-Tree/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article></main><footer class="foot"><div class="foot-copy u-fl">&copy; 2016 Dongmin Wu</div><menu class="page-menu u-fr"><li class="page-menu__item"><a title="Previous" href="/2015/06/07/Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/" class="page-menu__link icon-arrow-left"></a></li><li class="page-menu__item"><a title="Next" href="/2015/06/03/post-order-Traversal-of-btree/" class="page-menu__link icon-arrow-right"></a></li></menu></footer></body></html>